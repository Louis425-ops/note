# 数据库

## 数据库概述

### 为什么使用数据库？

在以前的开发中，我们可能用文件存储数据：

```c
FILE *file;
char filename[] = "map.txt";
file = fopen(filename, "r");
while (fgets(line, sizeof(line), file) != NULL)
    // 处理数据
```

但面对复杂需求，文件存储明显就不够用了

### 数据库的引入

**数据库(DB)** 是有组织的数据集合，通过**数据库管理系统(DBMS)**进行管理。常见的DBMS有MySQL等

## 数据模型

### 关系模型（重点）

关系型数据库以表格形式存储数据：

**Tuple**：每一行，表示一个记录       **Attribute**：每一列，表示数据字段

## SQL 基础操作

### 数据表的CRUD操作

#### Create

```sql
-- 插入所有字段
INSERT INTO demo
VALUES (28, 'sql', 'hi');

-- 插入指定字段
INSERT INTO demo (ID)
VALUES (29);
```

#### Read

```sql
-- 查询所有数据
SELECT * FROM demo;

-- 查询指定字段
SELECT name, hint FROM demo;

-- 条件查询
SELECT name, hint FROM demo
WHERE name='sql';
```

#### Update

```sql
UPDATE demo
SET name='SQL'
WHERE hint='hi';
```

#### Delete

```sql
DELETE FROM demo
WHERE id = 29;
```

### 数据库的CRUD操作

```sql
CREATE DATABASE databasename;

USE databasename;

SHOW databases;

DROP DATABASE databasename;
```

### 数据表管理

#### 创建表

```sql
CREATE TABLE demo (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name VARCHAR(20),
    hint TEXT
);
```

#### 显示和删除表

```sql
-- 显示所有表
SHOW tables;

-- 删除表
DROP TABLE table_name;
```

## 完整性约束

### 主要约束类型

#### 非空约束

```sql
name VARCHAR(20) NOT NULL
```

#### 主键约束

```sql
id INTEGER PRIMARY KEY
```

#### 外键约束

```sql
CREATE TABLE department(
    dept_name VARCHAR(20) PRIMARY KEY,
    building VARCHAR(20)
);

CREATE TABLE student (
    ID VARCHAR(5) PRIMARY KEY,
    name VARCHAR(20) NOT NULL,
    dept_name VARCHAR(20),
    FOREIGN KEY (dept_name) REFERENCES department(dept_name)
);
```

#### 级联操作

```sql
FOREIGN KEY (dept_name) REFERENCES department(dept_name)
ON DELETE CASCADE
ON UPDATE SET NULL
```

## 高级查询

### 表连接

#### 普通连接

```sql
SELECT name, course_id
FROM instructor, teaches
WHERE instructor.ID = teaches.ID;
```

#### 自然连接

```sql
SELECT name, course_id
FROM instructor NATURAL JOIN teaches;
```

### 聚合函数

```sql
-- 统计课程数量
SELECT COUNT(*) FROM course;

-- 计算平均薪资
SELECT AVG(salary)
FROM instructor
WHERE dept_name = 'Comp. Sci.';

-- 按部门分组统计
SELECT dept_name, AVG(salary)
FROM instructor
GROUP BY dept_name;
```

### 限定词和谓词

#### 去重和保留重复

```sql
-- 去重
SELECT DISTINCT dept_name FROM instructor;

-- 保留重复
SELECT ALL dept_name FROM instructor;
```

#### 范围查询

```sql
-- 范围限定
SELECT name FROM instructor
WHERE salary BETWEEN 90000 AND 100000;

-- 逻辑连接
SELECT name FROM instructor
WHERE dept_name = 'Comp. Sci.' AND salary > 80000;
```

#### 排序和限制

```sql
-- 排序
SELECT DISTINCT name FROM instructor
ORDER BY name DESC;

-- 限制结果数量
SELECT DISTINCT name FROM instructor
ORDER BY name DESC
LIMIT 3;
```

## 事务管理

### 基本语法

```sql
-- 开启事务
BEGIN;

-- 执行操作
UPDATE accounts SET balance = balance - 100 WHERE user = 'A';
UPDATE accounts SET balance = balance + 100 WHERE user = 'B';

-- 提交事务
COMMIT;

-- 回滚事务（出错时）
ROLLBACK;
```

### 事务控制

```sql
-- 开启事务
START TRANSACTION;

-- 插入数据
INSERT INTO customers VALUES (4, 'Chaitali', 25, 'Mumbai', 6500);
INSERT INTO customers VALUES (5, 'Hardik', 27, 'Bhopal', 8500);

-- 提交变更
COMMIT;
```

## Golang数据库开发

### 数据库配置

config.json e.g：

```json
{
  "database": {
    "host": "localhost",
    "port": 5432,
    "user": "myusername",
    "password": "mypassword",
    "dbname": "mygo"
  }
}
```

### 数据库连接(init.go)

```go
package main

import (
    "gorm.io/gorm"
    "gorm.io/driver/postgres"
    "github.com/spf13/viper"
)

var DB *gorm.DB

func InitDB() {
    // 读取配置
    viper.SetConfigFile("config/config.json")
    viper.ReadInConfig()
    
    // 构建连接字符串
    dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s",
        viper.GetString("database.host"),
        viper.GetInt("database.port"),
        viper.GetString("database.user"),
        viper.GetString("database.password"),
        viper.GetString("database.dbname"))
    
    // 连接数据库
    var err error
    DB, err = gorm.Open(postgres.Open(dsn), &gorm.Config{})
    if err != nil {
        log.Fatal("数据库连接失败:", err)
    }
    
    // 自动迁移
    DB.AutoMigrate(&User{}, &Comment{})
}
```

### 数据模型定义(model.go)

```go
package main

import "time"

// 用户模型
type User struct {
    ID       int    `json:"id" gorm:"primaryKey;autoIncrement"`
    Name     string `json:"name" gorm:"not null"`
    Email    string `json:"email" gorm:"unique"`
    DeptName string `json:"dept_name"`
}

// 评论模型  
type Comment struct {
    ID      int       `json:"id" gorm:"primaryKey;autoIncrement"`
    Name    string    `json:"name"`
    Content string    `json:"content"`
    Created time.Time `json:"created" gorm:"autoCreateTime"`
}

// 统一响应格式
type Response struct {
    Code int         `json:"code"`
    Msg  string      `json:"message"`
    Data interface{} `json:"data"`
}
```

### HTTP服务器(server.go)

```go
package main

import (
    "encoding/json"
    "net/http"
    "strconv"
)

// GET请求处理
func handleGetComments(w http.ResponseWriter, r *http.Request) {
    // 设置跨域头
    w.Header().Set("Access-Control-Allow-Origin", "*")
    w.Header().Set("Content-Type", "application/json")
    
    // 获取查询参数
    page, err := strconv.Atoi(r.URL.Query().Get("page"))
    if err != nil || page < 1 {
        page = 1
    }
    
    // 查询数据库
    var comments []Comment
    result := DB.Offset((page-1)*10).Limit(10).Find(&comments)
    if result.Error != nil {
        http.Error(w, "查询失败", http.StatusInternalServerError)
        return
    }
    
    // 返回响应
    response := Response{
        Code: 0,
        Msg:  "success",
        Data: map[string]interface{}{
            "total": len(comments),
            "items": comments,
        },
    }
    
    json.NewEncoder(w).Encode(response)
}

// POST请求处理
func handlePostComment(w http.ResponseWriter, r *http.Request) {
    // 设置跨域头
    w.Header().Set("Access-Control-Allow-Origin", "*")
    w.Header().Set("Content-Type", "application/json")
    
    // 解析请求体
    var requestData struct {
        Name    string `json:"name"`
        Content string `json:"content"`
    }
    
    if err := json.NewDecoder(r.Body).Decode(&requestData); err != nil {
        http.Error(w, "无效的请求格式", http.StatusBadRequest)
        return
    }
    
    // 创建评论
    comment := Comment{
        Name:    requestData.Name,
        Content: requestData.Content,
    }
    
    result := DB.Create(&comment)
    if result.Error != nil {
        http.Error(w, "创建失败", http.StatusInternalServerError)
        return
    }
    
    // 返回响应
    response := Response{
        Code: 0,
        Msg:  "创建成功",
        Data: comment,
    }
    
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(response)
}

// 跨域处理
func handleCORS(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Access-Control-Allow-Origin", "*")
    w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
    w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
    
    if r.Method == "OPTIONS" {
        w.WriteHeader(http.StatusNoContent)
        return
    }
}

func StartServer() {
    http.HandleFunc("/comments", func(w http.ResponseWriter, r *http.Request) {
        handleCORS(w, r)
        
        switch r.Method {
        case "GET":
            handleGetComments(w, r)
        case "POST":
            handlePostComment(w, r)
        }
    })
    
    log.Println("服务器启动在 :8080")
    http.ListenAndServe(":8080", nil)
}
```

### 主程序(main.go)

```go
package main

import "log"

func main() {
    // 初始化数据库
    InitDB()
    log.Println("数据库连接成功")
    
    // 启动HTTP服务器
    StartServer()
}
```

### Go语言关键语法

#### 错误处理

```go
result, err := SomeFunc()
if err != nil {
    log.Fatal("操作失败:", err)
    return
}
```

#### 结构体方法

```go
// 值接收器
func (u User) GetName() string {
    return u.Name
}

// 指针接收器（可修改原对象）
func (u *User) UpdateName(name string) {
    u.Name = name
}
```

#### 接口定义

```go
type Speaker interface {
    Speak() string
}

type Dog struct{}

func (d Dog) Speak() string {
    return "Woof!"
}
```